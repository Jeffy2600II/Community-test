<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Community Home</title>
  <link rel="stylesheet" href="/css/style.css">
  <style>
    /* Feed & content visuals */
    .post { position: relative; padding: 12px; border-radius: 10px; background: linear-gradient(180deg,#fff,#fcfdff); margin-bottom: 12px; border: 1px solid rgba(15,23,42,0.03); }
    .post-header { display:flex; align-items:center; gap:12px; width:100%; }
    .post-avatar .avatar-img { width:48px; height:48px; border-radius:10px; object-fit: cover; }
    .post-header-meta { display:flex; flex-direction:column; gap:2px; min-width:0; }
    .post-username a { font-weight:700; color:var(--text); text-decoration:none; display:inline-block; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:240px; }
    .post-time { color:var(--muted); font-size:0.88rem; }

    .post-body { margin-top:10px; line-height:1.55; }
    .post-content { color:#38414b; white-space:pre-wrap; word-break:break-word; }
    .post-img { margin-top:10px; max-width:100%; height:auto; border-radius:8px; }

    /* make whole post show pointer, but interactive children keep their own cursor */
    .post { cursor: pointer; }
    .post a, .post button, .post input, .post textarea { cursor: auto; }

    /* Kebab placed on the right side of the header */
    .post-kebab { background: transparent; border: none; cursor:pointer; width:36px; height:36px; display:inline-flex; align-items:center; justify-content:center; border-radius:8px; margin-left: auto; }
    .post-kebab:focus { outline: 2px solid rgba(47,128,237,0.12); }
    /* popup should align to the right of the post when kebab is on the right */
    .post-popup { position:absolute; right:8px; top:44px; left: auto; background:var(--surface); border:1px solid rgba(15,23,42,0.06); border-radius:10px; box-shadow:0 10px 30px rgba(16,24,40,0.08); }
    .post-popup a, .post-popup button { display:block; width:100%; padding:10px 12px; text-align:left; border:none; background:transparent; cursor:pointer; font-weight:600; color:var(--text); }
    .post-popup a:hover, .post-popup button:hover { background:#fbfdff; }

    /* Hide inline actions in feed (we use popup) */
    .post-actions { display:none; }

    /* Excerpt clamp for long posts (if you want CSS clamp instead of JS truncation) */
    .post-excerpt a.post-link {
      color: inherit;
      text-decoration: none;
      display: -webkit-box;
      -webkit-box-orient: vertical;
      overflow: hidden;
      text-overflow: ellipsis;
      -webkit-line-clamp: 5;
    }

    @media (max-width:560px) {
      .post-username a { max-width:140px; }
    }
  </style>
</head>
<body>
  <div id="headerSlot"></div>

  <main>
    <div class="container">
      <div class="card">
        <div class="section-title"><span>ฟีดโพสต์ล่าสุด</span></div>
        <div id="feed" class="feed">
          <i class="small">กำลังโหลด...</i>
        </div>
      </div>
    </div>
  </main>

  <div id="footerSlot"></div>

  <!-- main.js ต้องถูกโหลดเพื่อเติม partial header/footer และจัดการ header interactions -->
  <script src="/js/main.js"></script>

  <script>
  (function () {
    // Escape HTML and preserve line breaks as <br>
    function escapeAndFormat(text) {
      if (text === null || text === undefined) return '';
      const s = String(text)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
      return s.replace(/\r\n|\r|\n/g, '<br>');
    }

    // Truncate to approx N chars without cutting words awkwardly
    function truncateText(str, max) {
      if (!str) return '';
      if (str.length <= max) return str;
      const sub = str.slice(0, max);
      const lastSpace = sub.lastIndexOf(' ');
      if (lastSpace > Math.floor(max * 0.6)) return sub.slice(0, lastSpace) + '...';
      return sub + '...';
    }

    // Load logged-in username (if any)
    async function loadMyUsername() {
      try {
        const pr = await fetch('/api/profile');
        if (!pr.ok) return null;
        const data = await pr.json();
        if (data && data.success && data.profile) return data.profile.username;
      } catch (e) {}
      return null;
    }

    // Single popup control
    let openPopup = null;
    function closePopup() {
      if (openPopup && openPopup.parentElement) openPopup.remove();
      openPopup = null;
      document.querySelectorAll('.post-kebab[aria-expanded="true"]').forEach(b => b.setAttribute('aria-expanded','false'));
    }

    function attachGlobalPopupHandlers() {
      document.addEventListener('click', function (ev) {
        if (!ev.target.closest('.post-popup') && !ev.target.closest('.post-kebab')) closePopup();
      }, true);
      document.addEventListener('keydown', function (ev) {
        if (ev.key === 'Escape') closePopup();
      });
    }

    async function renderFeed() {
      const feedEl = document.getElementById('feed');
      feedEl.innerHTML = '';
      const myUsername = await loadMyUsername();

      let posts = [];
      try {
        const res = await fetch('/api/posts');
        if (res.ok) {
          const j = await res.json();
          posts = (j && j.posts) || [];
        }
      } catch (e) {
        console.error('failed to load posts', e);
        feedEl.innerHTML = '<div class="small">ไม่สามารถโหลดโพสต์ได้ขณะนี้</div>';
        return;
      }

      if (!posts.length) {
        feedEl.innerHTML = '<i class="small">ยังไม่มีโพสต์</i>';
        return;
      }

      for (const post of posts) {
        const art = document.createElement('article');
        art.className = 'post';
        art.dataset.postId = post.id;
        art.dataset.postOwner = post.username || '';
        art.tabIndex = 0; // make focusable for keyboard

        // header
        const header = document.createElement('div');
        header.className = 'post-header';

        // avatar
        const avatarLink = document.createElement('a');
        avatarLink.className = 'post-avatar';
        avatarLink.href = '/user/' + encodeURIComponent(post.username || '');
        avatarLink.style.display = 'inline-flex';
        avatarLink.style.alignItems = 'center';
        const img = document.createElement('img');
        img.className = 'avatar-img';
        img.alt = post.username || '';
        img.id = 'avatar-' + (post.username || 'u') + '-' + (post.id || 'x');
        // start with local default (so something always shows)
        img.src = '/img/default_profile.png';
        // add error handler to ensure we fallback to default if remote fails later
        img.onerror = function () {
          try { this.onerror = null; this.src = '/img/default_profile.png'; } catch (e) {}
        };
        avatarLink.appendChild(img);
        header.appendChild(avatarLink);

        // meta
        const meta = document.createElement('div');
        meta.className = 'post-header-meta';
        const nameDiv = document.createElement('div');
        nameDiv.className = 'post-username';
        const nameLink = document.createElement('a');
        nameLink.href = '/user/' + encodeURIComponent(post.username || '');
        nameLink.textContent = post.username || '(ไม่ระบุ)';
        nameDiv.appendChild(nameLink);
        const timeDiv = document.createElement('div');
        timeDiv.className = 'post-time small';
        timeDiv.textContent = new Date(post.createdAt).toLocaleString();
        meta.appendChild(nameDiv);
        meta.appendChild(timeDiv);
        header.appendChild(meta);

        // kebab button (right)
        const kebab = document.createElement('button');
        kebab.className = 'post-kebab';
        kebab.type = 'button';
        kebab.setAttribute('aria-haspopup','true');
        kebab.setAttribute('aria-expanded','false');
        kebab.title = 'ตัวเลือกโพสต์';
        kebab.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#97a0b3" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg>`;
        header.appendChild(kebab);

        art.appendChild(header);

        // body
        const body = document.createElement('div');
        body.className = 'post-body';

        // content (truncated by JS)
        const fullContent = post.content || '';
        const truncated = truncateText(fullContent, 1000);
        const formatted = escapeAndFormat(truncated);
        const contentDiv = document.createElement('div');
        contentDiv.className = 'post-content';
        contentDiv.innerHTML = formatted;
        // NOTE: do NOT stop propagation on contentDiv; overall article's click handler will navigate
        body.appendChild(contentDiv);

        // optional image
        if (post.image) {
          const im = document.createElement('img');
          im.className = 'post-img';
          im.src = post.image;
          im.alt = 'post image';
          im.loading = 'lazy';
          // clicking image should navigate to post (we let article handle it)
          body.appendChild(im);
        }

        // hidden actions placeholder
        const actions = document.createElement('div');
        actions.className = 'post-actions';
        body.appendChild(actions);

        art.appendChild(body);
        feedEl.appendChild(art);

        // attach click/key handlers on article to navigate to post unless interactive child clicked
        art.addEventListener('click', function (ev) {
          // if click was on an interactive element, ignore (let that element act)
          if (ev.target.closest('a, button, input, textarea, select, .post-popup, .post-kebab')) return;
          // otherwise navigate
          window.location.href = '/post/' + encodeURIComponent(post.id);
        });
        // keyboard: Enter or Space opens post (but not when focused on an interactive child)
        art.addEventListener('keydown', function (ev) {
          if (ev.key === 'Enter' || ev.key === ' ') {
            const active = document.activeElement;
            if (active && active !== art && active.closest && active.closest('a, button, input, textarea, select, .post-popup, .post-kebab')) {
              return; // interactive child focused — let it handle
            }
            ev.preventDefault();
            window.location.href = '/post/' + encodeURIComponent(post.id);
          }
        });
      }

      // after DOM created, load avatars and wire kebab
      loadAvatarsAndWireKebab(myUsername);
    }

    /**
     * Robust avatar loading:
     * - Start with local default image (already set).
     * - Collect unique usernames from images (id^="avatar-") and fetch /api/user/<username> once per username.
     * - Use a timeout wrapper for fetch to avoid hanging if API is slow or failing.
     * - On success and if a profilePic exists, set it for all matching imgs; otherwise keep default.
     * - Ensure each <img> has an onerror fallback to local default.
     */
    async function loadAvatarsAndWireKebab(myUsername) {
      const avatarImgs = Array.from(document.querySelectorAll('img[id^="avatar-"]'));
      if (!avatarImgs.length) return;
      const map = new Map(); // username -> [img nodes]

      // parse username from id pattern avatar-<username>-<postid>
      for (const img of avatarImgs) {
        const id = img.id || '';
        const parts = id.split('-');
        if (parts.length < 3) continue;
        const username = parts.slice(1, parts.length - 1).join('-');
        if (!map.has(username)) map.set(username, []);
        map.get(username).push(img);

        // defensive onerror (if image src later 404s)
        if (!img.onerror) {
          img.onerror = function () {
            try { this.onerror = null; this.src = '/img/default_profile.png'; } catch (e) {}
          };
        }
      }

      // helper: fetch with timeout
      function fetchWithTimeout(url, opts = {}, timeout = 5000) {
        return new Promise((resolve, reject) => {
          const timer = setTimeout(() => reject(new Error('timeout')), timeout);
          fetch(url, opts).then(r => {
            clearTimeout(timer);
            resolve(r);
          }).catch(err => {
            clearTimeout(timer);
            reject(err);
          });
        });
      }

      const requests = [];
      for (const username of map.keys()) {
        const url = '/api/user/' + encodeURIComponent(username);
        // we push username so we can map responses later
        requests.push({ username, promise: fetchWithTimeout(url, {}, 6000).catch(err => ({ __fetchError: err })) });
      }

      // run fetches in parallel and process results as they settle
      await Promise.all(requests.map(r => r.promise.then(()=>{},()=>{}))).catch(()=>{}); // ensure all started

      for (const req of requests) {
        const username = req.username;
        let resp;
        try {
          resp = await req.promise;
          // if our catch returned an error object, it's not a Response
          if (!resp || resp.__fetchError) throw resp && resp.__fetchError ? resp.__fetchError : new Error('fetch failed');
          if (!resp.ok) throw new Error('non-ok ' + resp.status);
          const j = await resp.json();
          if (j && j.success && j.profile && j.profile.profilePic) {
            const pic = j.profile.profilePic;
            const nodes = map.get(username) || [];
            for (const n of nodes) {
              try { n.src = pic; } catch (e) { /* ignore */ }
            }
            continue;
          } else {
            // no profilePic or success==false -> leave default
            // optional: could set title attribute or similar
            continue;
          }
        } catch (e) {
          // fetch failed / timeout / parse error => keep default; log for debugging
          console.warn('avatar load failed for', username, e && e.message ? e.message : e);
          continue;
        }
      }
    }

    async function loadAvatarsAndWireKebab_old(myUsername) {
      // kept for reference; original implementation used individual fetches without timeout
      const avatarImgs = Array.from(document.querySelectorAll('img[id^="avatar-"]'));
      const seen = new Set();
      for (const img of avatarImgs) {
        const parts = img.id.split('-');
        if (parts.length < 3) continue;
        const username = parts.slice(1, parts.length - 1).join('-');
        if (seen.has(username)) continue;
        seen.add(username);
        (async () => {
          try {
            const up = await fetch('/api/user/' + encodeURIComponent(username));
            if (!up.ok) return;
            const ud = await up.json();
            if (ud && ud.success && ud.profile && ud.profile.profilePic) {
              document.querySelectorAll('img[id^="avatar-' + username + '"]').forEach(i => {
                i.src = ud.profile.profilePic;
              });
            }
          } catch (e) {}
        })();
      }
    }

    // kebab behavior (delegated)
    const feed = document.getElementById('feed');
    feed.addEventListener('click', function (ev) {
      const kebab = ev.target.closest('.post-kebab');
      if (!kebab) return;
      ev.preventDefault();
      ev.stopPropagation();

      const postEl = kebab.closest('.post');
      if (!postEl) return;
      const postId = postEl.dataset.postId;
      const owner = postEl.dataset.postOwner;

      if (openPopup && openPopup.dataset.postId === postId) {
        closePopup();
        return;
      }
      closePopup();

      const popup = document.createElement('div');
      popup.className = 'post-popup';
      popup.dataset.postId = postId;

      const isOwner = (myUsername && owner && myUsername === owner);

      if (isOwner) {
        const editA = document.createElement('a');
        editA.href = '/post/' + encodeURIComponent(postId) + '/edit';
        editA.textContent = 'แก้ไขโพสต์';
        popup.appendChild(editA);

        const delBtn = document.createElement('button');
        delBtn.type = 'button';
        delBtn.textContent = 'ลบโพสต์';
        delBtn.addEventListener('click', async function (e) {
          e.preventDefault();
          if (!confirm('ลบโพสต์นี้?')) return;
          try {
            await fetch('/api/post/' + encodeURIComponent(postId), { method: 'DELETE' });
            const el = document.querySelector('.post[data-post-id="' + postId + '"]');
            if (el) el.remove();
          } catch (err) {
            alert('เกิดข้อผิดพลาดขณะลบโพสต์');
          } finally {
            closePopup();
          }
        });
        popup.appendChild(delBtn);
      } else {
        const profileA = document.createElement('a');
        profileA.href = '/user/' + encodeURIComponent(owner || '');
        profileA.textContent = 'ไปยังโปรไฟล์';
        popup.appendChild(profileA);

        const reportBtn = document.createElement('button');
        reportBtn.type = 'button';
        reportBtn.textContent = 'รายงานโพสต์';
        reportBtn.addEventListener('click', function () {
          alert('ฟีเจอร์รายงานยังไม่เปิดใช้งาน');
          closePopup();
        });
        popup.appendChild(reportBtn);
      }

      postEl.appendChild(popup);
      openPopup = popup;
      kebab.setAttribute('aria-expanded','true');
    }, true);

    attachGlobalPopupHandlers();
    document.addEventListener('DOMContentLoaded', renderFeed);
  })();
  </script>
</body>
</html>