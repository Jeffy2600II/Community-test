<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ดูโพสต์</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/comments.css">
    <style>
      /* (เดิม) post / gallery styles ... (เหมือนของ repo) */
      .post { position: relative; padding: 12px; border-radius: 10px; background: linear-gradient(180deg,#fff,#fcfdff); margin-bottom: 12px; border: 1px solid rgba(15,23,42,0.03); }
      .post-header { display:flex; align-items:flex-start; gap:12px; width:100%; margin-bottom:6px; }
      .post-avatar .avatar-img { width:48px; height:48px; border-radius:10px; object-fit: cover; flex-shrink:0; }
      .post-header-meta { display:flex; flex-direction:column; gap:2px; min-width:0; }
      .post-username a { font-weight:700; color:var(--text); text-decoration:none; display:inline-block; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:240px; }
      .post-time { color:var(--muted); font-size:0.88rem; }

      .post-body { margin-top: 4px; line-height:1.55; display:flex; flex-direction:column; gap:8px; }
      .post-content { color:#38414b; white-space:pre-wrap; word-break:break-word; }
      .post-img { margin-top:10px; max-width:100%; height:auto; border-radius:8px; display:block; }

      /* Kebab for post (existing) */
      .post-kebab { background: transparent; border: none; cursor:pointer; width:36px; height:36px; display:inline-flex; align-items:center; justify-content:center; border-radius:8px; margin-left: auto; }
      .post-kebab:focus { outline: 2px solid rgba(47,128,237,0.12); }

      .post-popup { position:absolute; right:8px; top:44px; left: auto; background:var(--surface); border:1px solid rgba(15,23,42,0.06); border-radius:10px; box-shadow:0 10px 30px rgba(16,24,40,0.08); }
      .post-popup a, .post-popup button { display:block; width:100%; padding:10px 12px; text-align:left; border:none; background:transparent; cursor:pointer; font-weight:600; color:var(--text); }
      .post-popup a:hover, .post-popup button:hover { background:#fbfdff; }

      /* Minor spacing so bottom fixed bar does not overlay content on very small screens */
      #postCard { padding-bottom: 32px; }
    </style>
</head>
<body>
  <div id="headerSlot"></div>
  <main>
    <div class="container">
      <div class="card" id="postCard">
        <div id="postBox"></div>
        <hr style="margin:16px 0;">
        <div id="commentBox" aria-live="polite" aria-label="คอมเมนต์"></div>
        <!-- spacer for non-JS fallback; will be updated by JS to match comment bar height -->
        <div id="commentSpacer" style="height: 0;"></div>
      </div>
    </div>
  </main>
  <div id="footerSlot"></div>

  <!-- Fixed comment input bar (ยึดติดด้านล่าง) -->
  <div id="commentInputBar" class="comment-input-bar" role="complementary" aria-label="เขียนคอมเมนต์">
    <form id="commentForm" class="comment-form" autocomplete="off">
      <div class="comment-input-row">
        <textarea name="content" id="commentContent" placeholder="เขียนคอมเมนต์..." required aria-label="เขียนคอมเมนต์"></textarea>
        <button type="submit" class="btn btn-primary" id="commentSubmit">ส่ง</button>
      </div>
    </form>
  </div>

<script src="/js/main.js"></script>
<script>
/*
  UI behavior for post + comments:
  - Render post (same as before)
  - Render comments as structured nodes
  - For each comment: if comment.username === myUsername => show kebab (3 dots)
      - kebab opens small dropdown with "แก้ไข" and "ลบ"
      - ลบ uses existing DELETE endpoint: /api/post/:postId/comment/:commentId
      - แก้ไข: inline textarea + Save/Cancel; save posts to new endpoint
        POST /api/post/:postId/comment/:commentId/edit  (server change required - snippet provided separately)
*/

const postId = location.pathname.split('/').pop();
let myUsername;
const commentBox = document.getElementById('commentBox');
const commentForm = document.getElementById('commentForm');
const commentContent = document.getElementById('commentContent');
const commentInputBar = document.getElementById('commentInputBar');
const commentSpacer = document.getElementById('commentSpacer');

function escapeHtml(s){ if (s===null||s===undefined) return ''; return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

/* --- create comment node with kebab --- */
function createCommentNode(c) {
  const art = document.createElement('article');
  art.className = 'post comment';
  art.dataset.commentId = c.id || '';

  // header
  const header = document.createElement('div');
  header.className = 'post-header';

  const avatarA = document.createElement('a');
  avatarA.className = 'post-avatar';
  avatarA.href = '/user/' + encodeURIComponent(c.username || '');
  avatarA.style.display = 'inline-flex';
  avatarA.style.alignItems = 'center';
  avatarA.style.textDecoration = 'none';

  const img = document.createElement('img');
  img.className = 'avatar-img';
  img.alt = c.username || '';
  img.dataset.username = c.username || '';
  img.src = c.profilePic || '/img/default_profile.png';
  avatarA.appendChild(img);
  header.appendChild(avatarA);

  const meta = document.createElement('div');
  meta.className = 'post-header-meta';
  const nameDiv = document.createElement('div');
  nameDiv.className = 'post-username';
  const nameLink = document.createElement('a');
  nameLink.href = '/user/' + encodeURIComponent(c.username || '');
  nameLink.textContent = (c.displayName || c.username) || '(ไม่ระบุ)';
  nameDiv.appendChild(nameLink);
  const timeDiv = document.createElement('div');
  timeDiv.className = 'post-time small';
  timeDiv.textContent = c.createdAt ? new Date(c.createdAt).toLocaleString() : '';
  meta.appendChild(nameDiv);
  meta.appendChild(timeDiv);
  header.appendChild(meta);

  // kebab for comment (only if owner)
  if (typeof myUsername !== 'undefined' && myUsername && c.username === myUsername) {
    const kebabBtn = document.createElement('button');
    kebabBtn.className = 'comment-kebab';
    kebabBtn.type = 'button';
    kebabBtn.setAttribute('aria-haspopup','true');
    kebabBtn.setAttribute('aria-expanded','false');
    kebabBtn.title = 'ตัวเลือกคอมเมนต์';
    kebabBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#97a0b3" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg>';
    // create dropdown container (hidden until opened)
    const dd = document.createElement('div');
    dd.className = 'comment-dropdown hidden';
    dd.style.position = 'absolute';
    dd.style.zIndex = '2000';

    // Append to header (position will be corrected)
    const wrapper = document.createElement('div');
    wrapper.style.marginLeft = 'auto';
    wrapper.style.position = 'relative';
    wrapper.appendChild(kebabBtn);
    wrapper.appendChild(dd);
    header.appendChild(wrapper);

    // handlers
    kebabBtn.addEventListener('click', function (ev) {
      ev.stopPropagation();
      const isOpen = kebabBtn.getAttribute('aria-expanded') === 'true';
      closeAllCommentDropdowns();
      if (isOpen) return;
      // build menu
      dd.innerHTML = '';
      dd.classList.remove('hidden');
      dd.style.right = '0';
      dd.style.top = '36px';
      dd.style.background = 'var(--surface)';
      dd.style.border = '1px solid rgba(15,23,42,0.06)';
      dd.style.borderRadius = '8px';
      dd.style.boxShadow = '0 8px 24px rgba(15,23,42,0.08)';
      dd.style.minWidth = '160px';
      // Edit
      const editBtn = document.createElement('button');
      editBtn.type = 'button';
      editBtn.className = 'comment-dd-btn';
      editBtn.textContent = 'แก้ไข';
      editBtn.style.display = 'block';
      editBtn.style.width = '100%';
      editBtn.style.padding = '10px';
      editBtn.style.border = 'none';
      editBtn.style.background = 'transparent';
      editBtn.style.textAlign = 'left';
      editBtn.style.cursor = 'pointer';
      dd.appendChild(editBtn);
      // Delete
      const delBtn = document.createElement('button');
      delBtn.type = 'button';
      delBtn.className = 'comment-dd-btn';
      delBtn.textContent = 'ลบ';
      delBtn.style.display = 'block';
      delBtn.style.width = '100%';
      delBtn.style.padding = '10px';
      delBtn.style.border = 'none';
      delBtn.style.background = 'transparent';
      delBtn.style.textAlign = 'left';
      delBtn.style.cursor = 'pointer';
      delBtn.style.color = 'var(--danger)';
      dd.appendChild(delBtn);

      kebabBtn.setAttribute('aria-expanded', 'true');

      // Edit click -> inline edit
      editBtn.addEventListener('click', function (e) {
        e.stopPropagation();
        // close dropdown
        dd.classList.add('hidden');
        kebabBtn.setAttribute('aria-expanded', 'false');
        openCommentInlineEditor(art, c);
      }, { once: true });

      // Delete click -> call DELETE endpoint
      delBtn.addEventListener('click', async function (e) {
        e.stopPropagation();
        if (!confirm('ลบคอมเมนต์นี้?')) {
          dd.classList.add('hidden');
          kebabBtn.setAttribute('aria-expanded', 'false');
          return;
        }
        try {
          const resp = await fetch(`/api/post/${encodeURIComponent(postId)}/comment/${encodeURIComponent(c.id)}`, { method: 'DELETE' });
          if (resp.ok) {
            // remove node
            art.remove();
          } else {
            alert('ไม่สามารถลบคอมเมนต์ได้');
          }
        } catch (err) {
          console.error(err);
          alert('เกิดข้อผิดพลาดเครือข่ายขณะลบคอมเมนต์');
        } finally {
          dd.classList.add('hidden');
          kebabBtn.setAttribute('aria-expanded', 'false');
        }
      }, { once: true });
    });
  } // end kebab-if-owner

  art.appendChild(header);

  // body
  const body = document.createElement('div');
  body.className = 'post-body';
  const contentDiv = document.createElement('div');
  contentDiv.className = 'post-content';
  contentDiv.innerHTML = escapeHtml(c.content || '').replace(/\r\n|\r|\n/g, '<br>');
  body.appendChild(contentDiv);

  art.appendChild(body);

  return art;
}

/* close any open comment dropdowns */
function closeAllCommentDropdowns() {
  document.querySelectorAll('.comment-dropdown').forEach(d => { d.classList.add('hidden'); });
  document.querySelectorAll('.comment-kebab').forEach(b => b.setAttribute('aria-expanded','false'));
}

/* inline editor for a comment node (replace content with textarea + Save/Cancel)
   This will POST to /api/post/:postId/comment/:commentId/edit (server change required).
*/
function openCommentInlineEditor(commentNode, commentObj) {
  const body = commentNode.querySelector('.post-body');
  const contentDiv = body.querySelector('.post-content');
  if (!contentDiv) return;

  // create editor area
  const editor = document.createElement('div');
  editor.style.display = 'flex';
  editor.style.flexDirection = 'column';
  editor.style.gap = '8px';

  const ta = document.createElement('textarea');
  ta.style.minHeight = '80px';
  ta.value = commentObj.content || '';
  ta.className = 'comment-edit-textarea';
  editor.appendChild(ta);

  const ctrl = document.createElement('div');
  ctrl.style.display = 'flex';
  ctrl.style.gap = '8px';
  ctrl.style.justifyContent = 'flex-end';

  const btnSave = document.createElement('button');
  btnSave.type = 'button';
  btnSave.className = 'btn btn-primary';
  btnSave.textContent = 'บันทึก';
  const btnCancel = document.createElement('button');
  btnCancel.type = 'button';
  btnCancel.className = 'btn btn-ghost';
  btnCancel.textContent = 'ยกเลิก';
  ctrl.appendChild(btnCancel);
  ctrl.appendChild(btnSave);
  editor.appendChild(ctrl);

  // swap nodes
  contentDiv.style.display = 'none';
  body.appendChild(editor);
  ta.focus();

  btnCancel.addEventListener('click', function () {
    editor.remove();
    contentDiv.style.display = '';
  });

  btnSave.addEventListener('click', async function () {
    const newContent = (ta.value || '').trim();
    if (!newContent) { alert('คอมเมนต์ต้องไม่ว่าง'); return; }
    btnSave.disabled = true;
    try {
      // NOTE: server must implement this endpoint for edit to work; see server snippet provided
      const res = await fetch(`/api/post/${encodeURIComponent(postId)}/comment/${encodeURIComponent(commentObj.id)}/edit`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content: newContent })
      });
      const j = await res.json();
      if (res.ok && j && j.success) {
        // update DOM
        contentDiv.innerHTML = escapeHtml(newContent).replace(/\r\n|\r|\n/g, '<br>');
        commentObj.content = newContent;
        editor.remove();
        contentDiv.style.display = '';
      } else {
        alert((j && j.msg) ? j.msg : 'ไม่สามารถบันทึกการแก้ไขได้');
        btnSave.disabled = false;
      }
    } catch (err) {
      console.error(err);
      alert('เกิดข้อผิดพลาดขณะบันทึกการแก้ไข');
      btnSave.disabled = false;
    }
  });
}

/* render comments */
function renderComments(comments) {
  commentBox.innerHTML = '';
  if (!comments || comments.length === 0) {
    const empty = document.createElement('i');
    empty.className = 'small';
    empty.textContent = 'ยังไม่มีคอมเมนต์';
    commentBox.appendChild(empty);
    return;
  }
  for (const c of comments) {
    const node = createCommentNode(c);
    commentBox.appendChild(node);
  }
  // load avatars for comments
  loadAvatarsForNodes(commentBox);
}

/* load avatars for images that have data-username attribute (dedupe requests) */
async function loadAvatarsForNodes(container) {
  const imgs = Array.from(container.querySelectorAll('img[data-username]'));
  const seen = new Set();
  const usernames = [];
  for (const img of imgs) {
    const u = (img.dataset.username || '').trim();
    if (!u) continue;
    if (seen.has(u)) continue;
    seen.add(u);
    usernames.push(u);
  }
  await Promise.all(usernames.map(async (username) => {
    try {
      const url = '/api/user/' + encodeURIComponent(username);
      const res = await fetch(url);
      if (!res.ok) return;
      const data = await res.json();
      if (!data || !data.success || !data.profile) return;
      const pic = data.profile.profilePic;
      if (!pic) return;
      container.querySelectorAll('img[data-username="' + CSS.escape(username) + '"]').forEach(i => {
        i.addEventListener('error', function onErr() { i.removeEventListener('error', onErr); i.src = '/img/default_profile.png'; }, { once: true });
        i.src = pic;
      });
    } catch (e) { console.warn('avatar fetch failed for', username); }
  }));
}

/* load post + comments */
async function loadPost() {
  try {
    const res = await fetch('/api/post/' + encodeURIComponent(postId));
    if (!res.ok) { document.getElementById('postBox').innerText = 'ไม่พบโพสต์'; return; }
    const data = await res.json();
    if (!data.success) return document.getElementById('postBox').innerText = 'ไม่พบโพสต์';
    const { post, comments, owner, myUsername: apiUsername } = data;
    myUsername = apiUsername;
    // build post DOM (same as before)
    const container = document.getElementById('postBox');
    container.innerHTML = '';
    const art = document.createElement('article');
    art.className = 'post';
    const header = document.createElement('div'); header.className = 'post-header';
    const avatarA = document.createElement('a'); avatarA.className = 'post-avatar'; avatarA.href = '/user/' + encodeURIComponent(post.username || '');
    const avatarImg = document.createElement('img'); avatarImg.className = 'avatar-img';
    avatarImg.alt = post.username || '';
    avatarImg.id = `avatar-${post.username}-${post.id}`;
    avatarImg.dataset.username = post.username || '';
    avatarImg.src = '/img/default_profile.png';
    avatarA.appendChild(avatarImg);
    header.appendChild(avatarA);
    const meta = document.createElement('div'); meta.className = 'post-header-meta';
    const nameDiv = document.createElement('div'); nameDiv.className = 'post-username';
    const nameLink = document.createElement('a'); nameLink.href = '/user/' + encodeURIComponent(post.username || ''); nameLink.textContent = post.username || '(ไม่ระบุ)';
    nameDiv.appendChild(nameLink);
    const timeDiv = document.createElement('div'); timeDiv.className = 'post-time small'; timeDiv.textContent = new Date(post.createdAt).toLocaleString();
    meta.appendChild(nameDiv); meta.appendChild(timeDiv);
    header.appendChild(meta);
    const kebab = document.createElement('button');
    kebab.className = 'post-kebab';
    kebab.type = 'button';
    kebab.setAttribute('aria-haspopup','true');
    kebab.setAttribute('aria-expanded','false');
    kebab.title = 'ตัวเลือกโพสต์';
    kebab.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#97a0b3" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg>';
    header.appendChild(kebab);
    art.appendChild(header);
    const body = document.createElement('div'); body.className = 'post-body';
    const contentDiv = document.createElement('div'); contentDiv.className = 'post-content';
    contentDiv.innerHTML = escapeHtml(post.content || '');
    body.appendChild(contentDiv);
    const imgs = Array.isArray(post.images) ? post.images.slice() : (post.image ? [post.image] : []);
    if (imgs.length === 1) {
      const im = document.createElement('img'); im.className = 'post-img'; im.src = imgs[0]; im.alt = 'post image'; im.loading = 'lazy'; body.appendChild(im);
    } else if (imgs.length > 1) {
      const gallery = document.createElement('div'); gallery.className = 'post-gallery';
      for (const src of imgs) {
        const im = document.createElement('img'); im.className = 'post-img'; im.src = src; im.alt = 'post image'; im.loading = 'lazy';
        gallery.appendChild(im);
      }
      body.appendChild(gallery);
    }
    art.appendChild(body);
    container.appendChild(art);

    // load avatar for post
    (async () => {
      try {
        const up = await fetch(`/api/user/${encodeURIComponent(post.username)}`);
        if (!up.ok) return;
        const ud = await up.json();
        if (ud && ud.success && ud.profile && ud.profile.profilePic) {
          const imgElem = document.getElementById("avatar-"+post.username+"-"+post.id);
          if (imgElem) imgElem.src = ud.profile.profilePic;
        }
      } catch(e){}
    })();

    // render comments with new structured UI
    renderComments(comments || []);

  } catch (e) {
    console.error('loadPost error', e);
  } finally {
    requestAnimationFrame(syncSpacerToBar);
  }
}

/* ensure spacer equals height of fixed input bar */
function syncSpacerToBar() {
  try {
    const h = commentInputBar ? commentInputBar.getBoundingClientRect().height : 0;
    commentSpacer.style.height = (h + 16) + 'px';
    const postCard = document.getElementById('postCard');
    if (postCard) postCard.style.paddingBottom = (h + 24) + 'px';
  } catch(e){}
}

window.addEventListener('load', () => { loadPost(); syncSpacerToBar(); });
window.addEventListener('resize', syncSpacerToBar);

/* submit comment handler (AJAX, existing API) */
commentForm.addEventListener('submit', async function (ev) {
  ev.preventDefault();
  const txt = (commentContent.value || '').trim();
  if (!txt) return;
  try {
    commentContent.disabled = true;
    document.getElementById('commentSubmit').disabled = true;
    const res = await fetch('/api/post/' + encodeURIComponent(postId) + '/comment', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ content: txt })
    });
    const data = await res.json();
    if (data && data.success) {
      commentContent.value = '';
      await loadPost();
      setTimeout(() => { window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' }); }, 60);
    } else {
      alert((data && data.msg) ? data.msg : 'ไม่สามารถส่งคอมเมนต์ได้');
    }
  } catch (e) {
    console.error('submit comment error', e);
    alert('เกิดข้อผิดพลาดขณะส่งคอมเมนต์');
  } finally {
    commentContent.disabled = false;
    document.getElementById('commentSubmit').disabled = false;
  }
});

/* close dropdowns when clicking outside */
document.addEventListener('click', function () { closeAllCommentDropdowns(); }, true);

</script>
</body>
</html>