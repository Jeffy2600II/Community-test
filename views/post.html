<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ดูโพสต์</title>
    <link rel="stylesheet" href="/css/style.css">
    <style>
      /* Make single-post layout match feed/index.html 100% for post structure and gallery behavior.
         All post-related classes (.post, .post-header, .post-body, .post-gallery, .post-img, etc.)
         mirror the feed page so visuals/interaction are identical. */

      .post { position: relative; padding: 12px; border-radius: 10px; background: linear-gradient(180deg,#fff,#fcfdff); margin-bottom: 12px; border: 1px solid rgba(15,23,42,0.03); }
      .post-header { display:flex; align-items:flex-start; gap:12px; width:100%; margin-bottom:6px; }
      .post-avatar .avatar-img { width:48px; height:48px; border-radius:10px; object-fit: cover; flex-shrink:0; }
      .post-header-meta { display:flex; flex-direction:column; gap:2px; min-width:0; }
      .post-username a { font-weight:700; color:var(--text); text-decoration:none; display:inline-block; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:240px; }
      .post-time { color:var(--muted); font-size:0.88rem; }

      .post-body { margin-top: 4px; line-height:1.55; display:flex; flex-direction:column; gap:8px; }
      .post-content { color:#38414b; white-space:pre-wrap; word-break:break-word; }
      .post-img { margin-top:10px; max-width:100%; height:auto; border-radius:8px; display:block; }

      /* Horizontal scrolling gallery — identical rules to index.html */
      .post-gallery {
        display: flex;
        gap: 8px;
        margin-top: 10px;
        overflow-x: auto;
        overflow-y: hidden;
        align-items: flex-start;         /* anchor all images to the top */
        -webkit-overflow-scrolling: touch;
        padding-bottom: 6px;             /* breathing room for horizontal scroll */
        scroll-behavior: smooth;
      }
      .post-gallery .post-img {
        flex: 0 0 auto;                  /* do not shrink/grow, keep intrinsic sizing within limits */
        align-self: flex-start;          /* ensure each image is aligned to top of the gallery row */
        max-height: 420px;               /* max height for images in the gallery */
        max-width: calc(100vw - 96px);   /* ensure very wide images scale down to fit viewport when viewed */
        height: auto;
        width: auto;
        object-fit: contain;             /* avoid cropping; preserve full image within the max box */
        border-radius: 8px;
        display: block;
      }
      .post-gallery.only-one .post-img {
        max-height: 75vh;
        max-width: 100%;
      }

      /* Kebab & popup: same layout as index */
      .post-kebab { background: transparent; border: none; cursor:pointer; width:36px; height:36px; display:inline-flex; align-items:center; justify-content:center; border-radius:8px; margin-left: auto; }
      .post-kebab:focus { outline: 2px solid rgba(47,128,237,0.12); }

      .post-popup { position:absolute; right:8px; top:44px; left: auto; background:var(--surface); border:1px solid rgba(15,23,42,0.06); border-radius:10px; box-shadow:0 10px 30px rgba(16,24,40,0.08); }
      .post-popup a, .post-popup button { display:block; width:100%; padding:10px 12px; text-align:left; border:none; background:transparent; cursor:pointer; font-weight:600; color:var(--text); }
      .post-popup a:hover, .post-popup button:hover { background:#fbfdff; }

      .post-actions { display:none; }

      /* ---------------------------
         Comment styles (mirror post header/body structure)
         --------------------------- */
      .comment {
        display: flex;
        gap: 12px;
        align-items: flex-start;
        padding: 10px;
        background: #fbfdff;
        border: 1px solid rgba(15,23,42,0.03);
        border-radius: 8px;
        margin-bottom: 10px;
      }
      .comment .comment-avatar {
        flex-shrink: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
      }
      .comment .comment-avatar .avatar-img {
        width: 40px;
        height: 40px;
        border-radius: 8px;
        object-fit: cover;
        border: 1px solid rgba(15,23,42,0.06);
      }
      .comment .comment-body {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .comment .comment-meta {
        display: flex;
        gap: 8px;
        align-items: center;
        justify-content: flex-start;
      }
      .comment .comment-meta .comment-username {
        font-weight: 700;
        color: var(--text);
        text-decoration: none;
      }
      .comment .comment-meta .comment-time {
        color: var(--muted);
        font-size: 0.85rem;
      }
      .comment .comment-content {
        color: #38414b;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .comment .comment-actions {
        margin-top: 6px;
        display:flex;
        gap:8px;
      }
      @media (max-width:800px) {
        .post-header .post-avatar .avatar-img { width:44px; height:44px; }
        .post-header-meta .post-username a { font-size:0.95rem; }
        .post-time { font-size:0.80rem; }
        .post-gallery .post-img { max-height: 260px; max-width: calc(100vw - 56px); }
        .comment .comment-avatar .avatar-img { width:36px; height:36px; }
      }
    </style>
</head>
<body>
  <div id="headerSlot"></div>
  <main>
    <div class="container">
      <div class="card" id="postCard">
        <div id="postBox"></div>
        <hr style="margin:16px 0;">
        <div id="commentBox" aria-live="polite"></div>
        <form id="commentForm" class="mt-16 hidden">
          <label class="small">แสดงความคิดเห็น</label>
          <textarea name="content" placeholder="แสดงความคิดเห็น" required></textarea>
          <div class="text-right mt-16">
            <button type="submit" class="btn btn-primary">แสดงความคิดเห็น</button>
          </div>
        </form>
      </div>
    </div>
  </main>
  <div id="footerSlot"></div>

<script src="/js/main.js"></script>
<script>
/*
  This script renders the single post using the same DOM structure and gallery behavior as index.html.
  Comments are rendered as structured DOM nodes mirroring post header/body: avatar + body (meta+content).
*/
const postId = location.pathname.split('/').pop();
let myUsername;

function escapeHtml(s){ if (s===null||s===undefined) return ''; return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

async function loadPost() {
    const res = await fetch('/api/post/' + encodeURIComponent(postId));
    const data = await res.json();
    if (!data.success) return document.getElementById('postBox').innerText = 'ไม่พบโพสต์';
    const { post, comments, owner, myUsername: apiUsername } = data;
    myUsername = apiUsername;

    // Build DOM using same structure as feed (content first, then images)
    const container = document.getElementById('postBox');
    container.innerHTML = '';
    const art = document.createElement('article');
    art.className = 'post';

    // header
    const header = document.createElement('div'); header.className = 'post-header';
    const avatarA = document.createElement('a'); avatarA.className = 'post-avatar'; avatarA.href = '/user/' + encodeURIComponent(post.username || '');
    const avatarImg = document.createElement('img'); avatarImg.className = 'avatar-img'; avatarImg.alt = post.username || '';
    avatarImg.id = `avatar-${post.username}-${post.id}`;
    avatarImg.dataset.username = post.username || '';
    avatarImg.src = '/img/default_profile.png';
    avatarA.appendChild(avatarImg);
    header.appendChild(avatarA);

    const meta = document.createElement('div'); meta.className = 'post-header-meta';
    const nameDiv = document.createElement('div'); nameDiv.className = 'post-username';
    const nameLink = document.createElement('a'); nameLink.href = '/user/' + encodeURIComponent(post.username || ''); nameLink.textContent = post.username || '(ไม่ระบุ)';
    nameDiv.appendChild(nameLink);
    const timeDiv = document.createElement('div'); timeDiv.className = 'post-time small'; timeDiv.textContent = new Date(post.createdAt).toLocaleString();
    meta.appendChild(nameDiv); meta.appendChild(timeDiv);
    header.appendChild(meta);

    // kebab (same as feed)
    const kebab = document.createElement('button');
    kebab.className = 'post-kebab';
    kebab.type = 'button';
    kebab.setAttribute('aria-haspopup','true');
    kebab.setAttribute('aria-expanded','false');
    kebab.title = 'ตัวเลือกโพสต์';
    kebab.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#97a0b3" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg>`;
    header.appendChild(kebab);

    art.appendChild(header);

    // body
    const body = document.createElement('div'); body.className = 'post-body';

    // --- CONTENT FIRST (exactly like index) ---
    const contentDiv = document.createElement('div');
    contentDiv.className = 'post-content';
    contentDiv.innerHTML = escapeHtml(post.content || '');
    body.appendChild(contentDiv);

    // --- IMAGES AFTER CONTENT ---
    const imgs = Array.isArray(post.images) ? post.images.slice() : (post.image ? [post.image] : []);
    if (imgs.length === 1) {
      const im = document.createElement('img');
      im.className = 'post-img';
      im.src = imgs[0];
      im.alt = 'post image';
      im.loading = 'lazy';
      body.appendChild(im);
    } else if (imgs.length > 1) {
      const gallery = document.createElement('div');
      gallery.className = 'post-gallery';
      if (imgs.length === 1) gallery.classList.add('only-one');
      for (const src of imgs) {
        const im = document.createElement('img');
        im.className = 'post-img';
        im.src = src;
        im.alt = 'post image';
        im.loading = 'lazy';
        gallery.appendChild(im);
      }
      body.appendChild(gallery);
    }

    const actionsDiv = document.createElement('div'); actionsDiv.className = 'post-actions';
    if (myUsername === post.username) {
      const editA = document.createElement('a'); editA.className = 'btn btn-ghost'; editA.href = '/post/' + post.id + '/edit'; editA.textContent = 'แก้ไข';
      actionsDiv.appendChild(editA);
      const delBtn = document.createElement('button'); delBtn.className = 'btn btn-ghost'; delBtn.id = 'delBtn'; delBtn.type='button'; delBtn.textContent = 'ลบ';
      actionsDiv.appendChild(delBtn);
    }
    body.appendChild(actionsDiv);

    art.appendChild(body);
    container.appendChild(art);

    // load avatar similarly to feed implementation (apply profilePic to avatar image)
    (async () => {
      try {
        const up = await fetch(`/api/user/${encodeURIComponent(post.username)}`);
        const ud = await up.json();
        if (ud && ud.success && ud.profile && ud.profile.profilePic) {
          const imgElem = document.getElementById("avatar-"+post.username+"-"+post.id);
          if (imgElem) imgElem.src = ud.profile.profilePic;
        }
      } catch(e){}
    })();

    // kebab popup logic (same behavior as feed)
    kebab.addEventListener('click', function(ev) {
      ev.preventDefault();
      ev.stopPropagation();
      // remove existing popup
      const existing = art.querySelector('.post-popup');
      if (existing) { existing.remove(); kebab.setAttribute('aria-expanded','false'); return; }

      const popup = document.createElement('div');
      popup.className = 'post-popup';
      popup.dataset.postId = post.id;

      const isOwner = (myUsername && post.username && myUsername === post.username);

      if (isOwner) {
        const editA = document.createElement('a');
        editA.href = '/post/' + encodeURIComponent(post.id) + '/edit';
        editA.textContent = 'แก้ไขโพสต์';
        popup.appendChild(editA);

        const delBtn = document.createElement('button');
        delBtn.type = 'button';
        delBtn.textContent = 'ลบโพสต์';
        delBtn.addEventListener('click', async function (e) {
          e.preventDefault();
          if (!confirm('ลบโพสต์นี้?')) return;
          try {
            await fetch('/api/post/' + encodeURIComponent(post.id), { method: 'DELETE' });
            location.replace('/');
          } catch (err) {
            alert('เกิดข้อผิดพลาดขณะลบโพสต์');
          }
        });
        popup.appendChild(delBtn);
      } else {
        const profileA = document.createElement('a');
        profileA.href = '/user/' + encodeURIComponent(post.username || '');
        profileA.textContent = 'ไปยังโปรไฟล์';
        popup.appendChild(profileA);

        const reportBtn = document.createElement('button');
        reportBtn.type = 'button';
        reportBtn.textContent = 'รายงานโพสต์';
        reportBtn.addEventListener('click', function () {
          alert('ฟีเจอร์รายงานยังไม่เปิดใช้งาน');
        });
        popup.appendChild(reportBtn);
      }

      art.appendChild(popup);
      kebab.setAttribute('aria-expanded','true');
      // close popup when clicking outside
      setTimeout(() => {
        const onDoc = (ev) => {
          if (!popup.contains(ev.target) && ev.target !== kebab) {
            popup.remove();
            kebab.setAttribute('aria-expanded','false');
            document.removeEventListener('click', onDoc, true);
          }
        };
        document.addEventListener('click', onDoc, true);
      }, 0);
    });

    // render comments using structured DOM (avatar + body)
    renderComments(comments || []);
}

function renderComments(comments) {
    const box = document.getElementById('commentBox');
    box.innerHTML = ''; // clear
    const title = document.createElement('div');
    title.innerHTML = '<h3>คอมเมนต์</h3>';
    box.appendChild(title);

    if (!comments || comments.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'small';
      empty.innerText = 'ยังไม่มีคอมเมนต์';
      box.appendChild(empty);
      return;
    }

    const usernamesToFetch = new Set();

    for (const c of comments) {
        const cEl = document.createElement('div');
        cEl.className = 'comment';

        // avatar
        const avatarWrap = document.createElement('a');
        avatarWrap.className = 'comment-avatar';
        avatarWrap.href = '/user/' + encodeURIComponent(c.username || '');
        const aimg = document.createElement('img');
        aimg.className = 'avatar-img';
        aimg.alt = c.username || '';
        aimg.src = '/img/default_profile.png';
        aimg.dataset.username = c.username || '';
        avatarWrap.appendChild(aimg);
        cEl.appendChild(avatarWrap);

        // body
        const body = document.createElement('div');
        body.className = 'comment-body';

        const meta = document.createElement('div');
        meta.className = 'comment-meta';
        const nameA = document.createElement('a');
        nameA.className = 'comment-username';
        nameA.href = '/user/' + encodeURIComponent(c.username || '');
        nameA.textContent = c.username || '(ไม่ระบุ)';
        meta.appendChild(nameA);

        const timeDiv = document.createElement('div');
        timeDiv.className = 'comment-time small';
        try { timeDiv.textContent = new Date(c.createdAt).toLocaleString(); } catch(e) { timeDiv.textContent = c.createdAt || ''; }
        meta.appendChild(timeDiv);

        body.appendChild(meta);

        const content = document.createElement('div');
        content.className = 'comment-content';
        content.textContent = c.content || '';
        body.appendChild(content);

        // actions (delete for owner)
        if (myUsername && c.username && myUsername === c.username) {
          const actions = document.createElement('div');
          actions.className = 'comment-actions';
          const delBtn = document.createElement('button');
          delBtn.className = 'btn btn-ghost';
          delBtn.type = 'button';
          delBtn.textContent = 'ลบ';
          delBtn.addEventListener('click', async (ev) => {
            ev.preventDefault();
            if (!confirm('ลบคอมเมนต์นี้?')) return;
            try {
              await fetch(`/api/post/${encodeURIComponent(postId)}/comment/${encodeURIComponent(c.id)}`, { method: 'DELETE' });
              // reload comments after delete
              loadPost();
            } catch (err) {
              alert('ไม่สามารถลบคอมเมนต์ได้');
            }
          });
          actions.appendChild(delBtn);
          body.appendChild(actions);
        }

        cEl.appendChild(body);
        box.appendChild(cEl);

        if (c.username) usernamesToFetch.add(c.username);
    }

    // batch load avatars for comment authors (deduplicated)
    if (usernamesToFetch.size > 0) {
      usernamesToFetch.forEach(async (u) => {
        try {
          const resp = await fetch('/api/user/' + encodeURIComponent(u));
          if (!resp.ok) return;
          const j = await resp.json();
          if (!j || !j.success || !j.profile) return;
          const pic = j.profile.profilePic;
          if (!pic) return;
          document.querySelectorAll('.comment-avatar img[data-username="' + CSS.escape(u) + '"]').forEach(img => {
            img.addEventListener('error', function onErr() {
              img.removeEventListener('error', onErr);
              img.src = '/img/default_profile.png';
            }, { once: true });
            img.src = pic;
          });
        } catch (e) {
          // ignore per-user failures
        }
      });
    }
}

async function loadPostAndComments() {
  await loadPost();
}

async function loadPost() {
  // wrapper: call original loadPost logic above
  // We re-run the fetch that was done earlier (to support reloading comments after delete)
  try {
    const res = await fetch('/api/post/' + encodeURIComponent(postId));
    const data = await res.json();
    if (!data.success) return document.getElementById('postBox').innerText = 'ไม่พบโพสต์';
    const { post, comments, myUsername: apiUsername } = data;
    myUsername = apiUsername;

    // Rebuild post area using the same logic as earlier
    // For brevity, reuse the previously defined function by simply reusing its logic:
    // Clear and reconstruct postBox identical to prior logic
    const container = document.getElementById('postBox');
    container.innerHTML = '';
    const art = document.createElement('article'); art.className = 'post';

    // header
    const header = document.createElement('div'); header.className = 'post-header';
    const avatarA = document.createElement('a'); avatarA.className = 'post-avatar'; avatarA.href = '/user/' + encodeURIComponent(post.username || '');
    const avatarImg = document.createElement('img'); avatarImg.className = 'avatar-img'; avatarImg.alt = post.username || '';
    avatarImg.id = `avatar-${post.username}-${post.id}`;
    avatarImg.dataset.username = post.username || '';
    avatarImg.src = '/img/default_profile.png';
    avatarA.appendChild(avatarImg);
    header.appendChild(avatarA);

    const meta = document.createElement('div'); meta.className = 'post-header-meta';
    const nameDiv = document.createElement('div'); nameDiv.className = 'post-username';
    const nameLink = document.createElement('a'); nameLink.href = '/user/' + encodeURIComponent(post.username || ''); nameLink.textContent = post.username || '(ไม่ระบุ)';
    nameDiv.appendChild(nameLink);
    const timeDiv = document.createElement('div'); timeDiv.className = 'post-time small'; timeDiv.textContent = new Date(post.createdAt).toLocaleString();
    meta.appendChild(nameDiv); meta.appendChild(timeDiv);
    header.appendChild(meta);

    // kebab
    const kebab = document.createElement('button'); kebab.className = 'post-kebab'; kebab.type='button';
    kebab.setAttribute('aria-haspopup','true'); kebab.setAttribute('aria-expanded','false');
    kebab.title = 'ตัวเลือกโพสต์';
    kebab.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#97a0b3" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg>`;
    header.appendChild(kebab);

    art.appendChild(header);

    const body = document.createElement('div'); body.className = 'post-body';
    const contentDiv = document.createElement('div'); contentDiv.className = 'post-content'; contentDiv.innerHTML = escapeHtml(post.content || '');
    body.appendChild(contentDiv);

    const imgs = Array.isArray(post.images) ? post.images.slice() : (post.image ? [post.image] : []);
    if (imgs.length === 1) {
      const im = document.createElement('img');
      im.className = 'post-img';
      im.src = imgs[0];
      im.alt = 'post image';
      im.loading = 'lazy';
      body.appendChild(im);
    } else if (imgs.length > 1) {
      const gallery = document.createElement('div');
      gallery.className = 'post-gallery';
      if (imgs.length === 1) gallery.classList.add('only-one');
      for (const src of imgs) {
        const im = document.createElement('img');
        im.className = 'post-img';
        im.src = src;
        im.alt = 'post image';
        im.loading = 'lazy';
        gallery.appendChild(im);
      }
      body.appendChild(gallery);
    }

    const actionsDiv = document.createElement('div'); actionsDiv.className = 'post-actions';
    if (myUsername === post.username) {
      const editA = document.createElement('a'); editA.className = 'btn btn-ghost'; editA.href = '/post/' + post.id + '/edit'; editA.textContent = 'แก้ไข';
      actionsDiv.appendChild(editA);
      const delBtn = document.createElement('button'); delBtn.className = 'btn btn-ghost'; delBtn.id = 'delBtn'; delBtn.type='button'; delBtn.textContent = 'ลบ';
      actionsDiv.appendChild(delBtn);
    }
    body.appendChild(actionsDiv);
    art.appendChild(body);
    container.appendChild(art);

    // apply avatar for post author
    try {
      const up = await fetch(`/api/user/${encodeURIComponent(post.username)}`);
      const ud = await up.json();
      if (ud && ud.success && ud.profile && ud.profile.profilePic) {
        const imgElem = document.getElementById("avatar-"+post.username+"-"+post.id);
        if (imgElem) imgElem.src = ud.profile.profilePic;
      }
    } catch(e){}

    // wire kebab - same behavior as earlier
    kebab.addEventListener('click', function(ev) {
      ev.preventDefault();
      ev.stopPropagation();
      const existing = art.querySelector('.post-popup');
      if (existing) { existing.remove(); kebab.setAttribute('aria-expanded','false'); return; }

      const popup = document.createElement('div'); popup.className = 'post-popup';
      popup.dataset.postId = post.id;
      const isOwner = (myUsername && post.username && myUsername === post.username);
      if (isOwner) {
        const editA = document.createElement('a'); editA.href = '/post/' + encodeURIComponent(post.id) + '/edit'; editA.textContent = 'แก้ไขโพสต์'; popup.appendChild(editA);
        const delBtn = document.createElement('button'); delBtn.type = 'button'; delBtn.textContent = 'ลบโพสต์';
        delBtn.addEventListener('click', async function (e) {
          e.preventDefault();
          if (!confirm('ลบโพสต์นี้?')) return;
          try { await fetch('/api/post/' + encodeURIComponent(post.id), { method: 'DELETE' }); location.replace('/'); } catch (err) { alert('เกิดข้อผิดพลาดขณะลบโพสต์'); }
        });
        popup.appendChild(delBtn);
      } else {
        const profileA = document.createElement('a'); profileA.href = '/user/' + encodeURIComponent(post.username || ''); profileA.textContent = 'ไปยังโปรไฟล์'; popup.appendChild(profileA);
        const reportBtn = document.createElement('button'); reportBtn.type = 'button'; reportBtn.textContent = 'รายงานโพสต์';
        reportBtn.addEventListener('click', function () { alert('ฟีเจอร์รายงานยังไม่เปิดใช้งาน'); });
        popup.appendChild(reportBtn);
      }
      art.appendChild(popup);
      kebab.setAttribute('aria-expanded','true');
      setTimeout(() => {
        const onDoc = (ev) => {
          if (!popup.contains(ev.target) && ev.target !== kebab) { popup.remove(); kebab.setAttribute('aria-expanded','false'); document.removeEventListener('click', onDoc, true); }
        };
        document.addEventListener('click', onDoc, true);
      }, 0);
    });

    // render comments with structured DOM
    renderComments(comments || []);
  } catch (err) {
    console.error('loadPost error', err && err.message);
    document.getElementById('postBox').innerText = 'ไม่สามารถโหลดโพสต์ได้';
  }
}

// comment form submit
document.getElementById('commentForm').onsubmit = async e => {
    e.preventDefault();
    const fd = new FormData(e.target);
    const res = await fetch('/api/post/' + encodeURIComponent(postId) + '/comment', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(Object.fromEntries(fd.entries()))
    });
    const data = await res.json();
    if (data && data.success) {
        e.target.reset();
        loadPost(); // refresh post and comments
    } else {
        alert('ไม่สามารถส่งคอมเมนต์ได้');
    }
};

window.deleteComment = async (cid) => {
    if (confirm('ยืนยันลบคอมเมนต์?')) {
        await fetch(`/api/post/${encodeURIComponent(postId)}/comment/${encodeURIComponent(cid)}`, {method:'DELETE'});
        loadPost();
    }
};

// initial load
loadPost();
</script>
</body>
</html>