<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ดูโพสต์</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/comments.css">
    <style>
      /* Minimal page-scoped adjustments only — all post visuals moved into /css/style.css */
      /* Ensure the fixed comment bar spacer behavior remains */
      #postCard { padding-bottom: 32px; }
    </style>
</head>
<body>
  <div id="headerSlot"></div>
  <main>
    <div class="container">
      <div class="card" id="postCard">
        <div id="postBox"></div>
        <hr style="margin:16px 0;">
        <div id="commentBox" aria-live="polite" aria-label="คอมเมนต์"></div>
        <!-- spacer for non-JS fallback; will be updated by JS to match comment bar height -->
        <div id="commentSpacer" style="height: 0;"></div>
      </div>
    </div>
  </main>
  <div id="footerSlot"></div>

  <!-- Fixed comment input bar (ยึดติดด้านล่าง) -->
  <div id="commentInputBar" class="comment-input-bar" role="complementary" aria-label="เขียนคอมเมนต์">
    <form id="commentForm" class="comment-form" autocomplete="off">
      <div class="comment-input-row">
        <textarea name="content" id="commentContent" placeholder="เขียนคอมเมนต์..." required aria-label="เขียนคอมเมนต์"></textarea>
        <button type="submit" class="btn btn-primary" id="commentSubmit">ส่ง</button>
      </div>
    </form>
  </div>

<script src="/js/main.js"></script>
<script>
/*
  Updated:
  - Render comments as post-like DOM nodes (avatar, name, timestamp, content)
  - Added a kebab (three-dot) button to each comment which opens a small dropdown/popup
    with actions (delete for comment owner, or profile/report for others).
  - Kebab for comments is positioned at the right edge of the comment (same place as post kebab)
  - Fixed comment input bar at bottom; JS will ensure page content has spacer to avoid overlap
  - On submit: post to /api/post/:id/comment (same as before) and reload comments area
*/

const postId = location.pathname.split('/').pop();
let myUsername;
const commentBox = document.getElementById('commentBox');
const commentForm = document.getElementById('commentForm');
const commentContent = document.getElementById('commentContent');
const commentInputBar = document.getElementById('commentInputBar');
const commentSpacer = document.getElementById('commentSpacer');

function escapeHtml(s){ if (s===null||s===undefined) return ''; return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

// Create DOM node for a single comment (post-like structure but without images)
function createCommentNode(c) {
  const art = document.createElement('article');
  art.className = 'post comment';
  art.dataset.commentId = c.id || '';

  // header
  const header = document.createElement('div');
  header.className = 'post-header';

  const avatarA = document.createElement('a');
  avatarA.className = 'post-avatar';
  avatarA.href = '/user/' + encodeURIComponent(c.username || '');
  avatarA.style.display = 'inline-flex';
  avatarA.style.alignItems = 'center';
  avatarA.style.textDecoration = 'none';

  const img = document.createElement('img');
  img.className = 'avatar-img';
  img.alt = c.username || '';
  img.dataset.username = c.username || '';
  img.src = c.profilePic || '/img/default_profile.png';
  avatarA.appendChild(img);
  header.appendChild(avatarA);

  const meta = document.createElement('div');
  meta.className = 'post-header-meta';
  const nameDiv = document.createElement('div');
  nameDiv.className = 'post-username';
  const nameLink = document.createElement('a');
  nameLink.href = '/user/' + encodeURIComponent(c.username || '');
  nameLink.textContent = (c.displayName || c.username) || '(ไม่ระบุ)';
  nameDiv.appendChild(nameLink);
  const timeDiv = document.createElement('div');
  timeDiv.className = 'post-time small';
  timeDiv.textContent = c.createdAt ? new Date(c.createdAt).toLocaleString() : '';
  meta.appendChild(nameDiv);
  meta.appendChild(timeDiv);
  header.appendChild(meta);

  // kebab button for comment actions (three-dot)
  const kebab = document.createElement('button');
  kebab.className = 'post-kebab';
  kebab.type = 'button';
  kebab.setAttribute('aria-haspopup', 'true');
  kebab.setAttribute('aria-expanded', 'false');
  kebab.title = 'ตัวเลือกคอมเมนต์';
  kebab.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#97a0b3" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
    <circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg>`;
  // prevent the outer article click listener from firing when interacting with kebab
  kebab.addEventListener('click', function (ev) {
    ev.preventDefault();
    ev.stopPropagation();
    const existing = art.querySelector('.post-popup');
    if (existing) {
      existing.remove();
      kebab.setAttribute('aria-expanded', 'false');
      return;
    }

    const popup = document.createElement('div');
    popup.className = 'post-popup';
    popup.dataset.commentId = c.id || '';

    const isOwner = (myUsername && c.username && myUsername === c.username);

    if (isOwner) {
      const delBtn = document.createElement('button');
      delBtn.type = 'button';
      delBtn.textContent = 'ลบคอมเมนต์';
      delBtn.addEventListener('click', async function (e) {
        e.preventDefault();
        e.stopPropagation();
        if (!confirm('ลบคอมเมนต์นี้?')) return;
        try {
          // Attempt to delete comment via RESTful endpoint.
          // Server should support DELETE /api/post/:postId/comment/:commentId
          const resp = await fetch('/api/post/' + encodeURIComponent(postId) + '/comment/' + encodeURIComponent(c.id), {
            method: 'DELETE'
          });
          // Try parse JSON if provided
          let json = null;
          try { json = await resp.json(); } catch (err) {}
          if (resp.ok && (!json || json.success !== false)) {
            // remove node from DOM
            art.remove();
          } else {
            alert((json && json.msg) ? json.msg : 'ไม่สามารถลบคอมเมนต์ได้');
          }
        } catch (err) {
          console.error('delete comment error', err);
          alert('เกิดข้อผิดพลาดขณะลบคอมเมนต์');
        } finally {
          popup.remove();
          kebab.setAttribute('aria-expanded', 'false');
        }
      });
      popup.appendChild(delBtn);
    } else {
      const profileA = document.createElement('a');
      profileA.href = '/user/' + encodeURIComponent(c.username || '');
      profileA.textContent = 'ไปยังโปรไฟล์';
      popup.appendChild(profileA);

      const reportBtn = document.createElement('button');
      reportBtn.type = 'button';
      reportBtn.textContent = 'รายงานคอมเมนต์';
      reportBtn.addEventListener('click', function () {
        alert('ฟีเจอร์รายงานยังไม่เปิดใช้งาน');
        popup.remove();
        kebab.setAttribute('aria-expanded', 'false');
      });
      popup.appendChild(reportBtn);
    }

    // attach popup to the comment node and handle outside click to dismiss
    art.appendChild(popup);
    kebab.setAttribute('aria-expanded', 'true');
    setTimeout(() => {
      const onDoc = (ev) => {
        if (!popup.contains(ev.target) && ev.target !== kebab) {
          popup.remove();
          kebab.setAttribute('aria-expanded', 'false');
          document.removeEventListener('click', onDoc, true);
        }
      };
      document.addEventListener('click', onDoc, true);
    }, 0);
  }, { passive: false });

  header.appendChild(kebab);

  art.appendChild(header);

  // body
  const body = document.createElement('div');
  body.className = 'post-body';
  const contentDiv = document.createElement('div');
  contentDiv.className = 'post-content';
  // preserve new lines but escape
  contentDiv.innerHTML = escapeHtml(c.content || '').replace(/\r\n|\r|\n/g, '<br>');
  body.appendChild(contentDiv);

  art.appendChild(body);

  return art;
}

// Render comments array (replace previous string-based rendering)
function renderComments(comments) {
  commentBox.innerHTML = '';
  if (!comments || comments.length === 0) {
    const empty = document.createElement('i');
    empty.className = 'small';
    empty.textContent = 'ยังไม่มีคอมเมนต์';
    commentBox.appendChild(empty);
    return;
  }
  for (const c of comments) {
    const node = createCommentNode(c);
    commentBox.appendChild(node);
  }
  // after DOM inserted, load avatars for comments (deduplicated)
  loadAvatarsForNodes(commentBox);
}

// load avatars for images that have data-username attribute (dedupe requests)
async function loadAvatarsForNodes(container) {
  const imgs = Array.from(container.querySelectorAll('img[data-username]'));
  const seen = new Set();
  const usernames = [];
  for (const img of imgs) {
    const u = (img.dataset.username || '').trim();
    if (!u) continue;
    if (seen.has(u)) continue;
    seen.add(u);
    usernames.push(u);
  }
  // fetch profiles in parallel but not to exceed reasonable concurrency
  await Promise.all(usernames.map(async (username) => {
    try {
      const url = '/api/user/' + encodeURIComponent(username);
      const res = await fetch(url);
      if (!res.ok) return;
      const data = await res.json();
      if (!data || !data.success || !data.profile) return;
      const pic = data.profile.profilePic;
      if (!pic) return;
      container.querySelectorAll('img[data-username="' + CSS.escape(username) + '"]').forEach(i => {
        // set error handler once
        i.addEventListener('error', function onErr() {
          i.removeEventListener('error', onErr);
          i.src = '/img/default_profile.png';
        }, { once: true });
        i.src = pic;
      });
    } catch (e) {
      // ignore per-avatar fetch errors
      console.warn('avatar fetch failed for', username);
    }
  }));
}

// Load the post + comments from API and render
async function loadPost() {
  try {
    const res = await fetch('/api/post/' + encodeURIComponent(postId));
    if (!res.ok) { document.getElementById('postBox').innerText = 'ไม่พบโพสต์'; return; }
    const data = await res.json();
    if (!data.success) return document.getElementById('postBox').innerText = 'ไม่พบโพสต์';
    const { post, comments, owner, myUsername: apiUsername } = data;
    myUsername = apiUsername;
    // Build DOM for post (unchanged structure from earlier implementation)
    const container = document.getElementById('postBox');
    container.innerHTML = '';
    const art = document.createElement('article');
    art.className = 'post';

    // header
    const header = document.createElement('div'); header.className = 'post-header';
    const avatarA = document.createElement('a'); avatarA.className = 'post-avatar'; avatarA.href = '/user/' + encodeURIComponent(post.username || '');
    const avatarImg = document.createElement('img'); avatarImg.className = 'avatar-img';
    avatarImg.alt = post.username || '';
    avatarImg.id = `avatar-${post.username}-${post.id}`;
    avatarImg.dataset.username = post.username || '';
    avatarImg.src = '/img/default_profile.png';
    avatarA.appendChild(avatarImg);
    header.appendChild(avatarA);

    const meta = document.createElement('div'); meta.className = 'post-header-meta';
    const nameDiv = document.createElement('div'); nameDiv.className = 'post-username';
    const nameLink = document.createElement('a'); nameLink.href = '/user/' + encodeURIComponent(post.username || ''); nameLink.textContent = post.username || '(ไม่ระบุ)';
    nameDiv.appendChild(nameLink);
    const timeDiv = document.createElement('div'); timeDiv.className = 'post-time small'; timeDiv.textContent = new Date(post.createdAt).toLocaleString();
    meta.appendChild(nameDiv); meta.appendChild(timeDiv);
    header.appendChild(meta);

    const kebab = document.createElement('button');
    kebab.className = 'post-kebab';
    kebab.type = 'button';
    kebab.setAttribute('aria-haspopup','true');
    kebab.setAttribute('aria-expanded','false');
    kebab.title = 'ตัวเลือกโพสต์';
    kebab.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#97a0b3" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" c[...]
    header.appendChild(kebab);

    art.appendChild(header);

    // body
    const body = document.createElement('div'); body.className = 'post-body';
    const contentDiv = document.createElement('div'); contentDiv.className = 'post-content';
    contentDiv.innerHTML = escapeHtml(post.content || '');
    body.appendChild(contentDiv);

    const imgs = Array.isArray(post.images) ? post.images.slice() : (post.image ? [post.image] : []);
    if (imgs.length === 1) {
      const im = document.createElement('img'); im.className = 'post-img'; im.src = imgs[0]; im.alt = 'post image'; im.loading = 'lazy'; body.appendChild(im);
    } else if (imgs.length > 1) {
      const gallery = document.createElement('div'); gallery.className = 'post-gallery';
      if (imgs.length === 1) gallery.classList.add('only-one');
      for (const src of imgs) {
        const im = document.createElement('img'); im.className = 'post-img'; im.src = src; im.alt = 'post image'; im.loading = 'lazy';
        gallery.appendChild(im);
      }
      body.appendChild(gallery);
    }

    art.appendChild(body);
    container.appendChild(art);

    // load avatar for post (like feed)
    (async () => {
      try {
        const up = await fetch(`/api/user/${encodeURIComponent(post.username)}`);
        if (!up.ok) return;
        const ud = await up.json();
        if (ud && ud.success && ud.profile && ud.profile.profilePic) {
          const imgElem = document.getElementById("avatar-"+post.username+"-"+post.id);
          if (imgElem) imgElem.src = ud.profile.profilePic;
        }
      } catch(e){}
    })();

    // render comments area using structured nodes
    renderComments(comments || []);

    // wire kebab popup (simple)
    kebab.addEventListener('click', function(ev) {
      ev.preventDefault();
      ev.stopPropagation();
      const existing = art.querySelector('.post-popup');
      if (existing) { existing.remove(); kebab.setAttribute('aria-expanded','false'); return; }
      const popup = document.createElement('div'); popup.className = 'post-popup'; popup.dataset.postId = post.id;
      const isOwner = (myUsername && post.username && myUsername === post.username);
      if (isOwner) {
        const editA = document.createElement('a');
        editA.href = '/post/' + encodeURIComponent(post.id) + '/edit';
        editA.textContent = 'แก้ไขโพสต์';
        popup.appendChild(editA);

        const delBtn = document.createElement('button');
        delBtn.type = 'button';
        delBtn.textContent = 'ลบโพสต์';
        delBtn.addEventListener('click', async function (e) {
          e.preventDefault();
          if (!confirm('ลบโพสต์นี้?')) return;
          try {
            await fetch('/api/post/' + encodeURIComponent(post.id), { method: 'DELETE' });
            const el = document.querySelector('.post[data-post-id="' + post.id + '"]');
            if (el) el.remove();
            location.replace('/');
          } catch (err) {
            alert('เกิดข้อผิดพลาดขณะลบโพสต์');
          } finally {
            popup.remove();
            kebab.setAttribute('aria-expanded','false');
          }
        });
        popup.appendChild(delBtn);
      } else {
        const profileA = document.createElement('a');
        profileA.href = '/user/' + encodeURIComponent(post.username || '');
        profileA.textContent = 'ไปยังโปรไฟล์';
        popup.appendChild(profileA);

        const reportBtn = document.createElement('button');
        reportBtn.type = 'button';
        reportBtn.textContent = 'รายงานโพสต์';
        reportBtn.addEventListener('click', function () { alert('ฟีเจอร์รายงานยังไม่เปิดใช้งาน'); });
        popup.appendChild(reportBtn);
      }
      art.appendChild(popup);
      kebab.setAttribute('aria-expanded','true');
      setTimeout(() => {
        const onDoc = (ev) => { if (!popup.contains(ev.target) && ev.target !== kebab) { popup.remove(); kebab.setAttribute('aria-expanded','false'); document.removeEventListener('click', onDoc, true)[...]
        document.addEventListener('click', onDoc, true);
      }, 0);
    });

  } catch (e) {
    console.error('loadPost error', e);
  } finally {
    // ensure spacer height matches input bar so content isn't hidden
    requestAnimationFrame(syncSpacerToBar);
  }
}

// ensure spacer equals height of fixed input bar
function syncSpacerToBar() {
  try {
    const h = commentInputBar ? commentInputBar.getBoundingClientRect().height : 0;
    commentSpacer.style.height = (h + 16) + 'px'; // extra breathing room
    // also ensure postCard has bottom padding on very small screens
    const postCard = document.getElementById('postCard');
    if (postCard) postCard.style.paddingBottom = (h + 24) + 'px';
  } catch(e){}
}

window.addEventListener('load', () => { loadPost(); syncSpacerToBar(); });
window.addEventListener('resize', syncSpacerToBar);

// submit comment handler (AJAX)
commentForm.addEventListener('submit', async function (ev) {
  ev.preventDefault();
  const txt = (commentContent.value || '').trim();
  if (!txt) return;
  const payload = { content: txt };
  try {
    commentContent.disabled = true;
    document.getElementById('commentSubmit').disabled = true;
    const res = await fetch('/api/post/' + encodeURIComponent(postId) + '/comment', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    const data = await res.json();
    if (data && data.success) {
      commentContent.value = '';
      // reload comments only, by calling loadPost
      await loadPost();
      // scroll to bottom of comments (new comment)
      setTimeout(() => { window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' }); }, 60);
    } else {
      alert((data && data.msg) ? data.msg : 'ไม่สามารถส่งคอมเมนต์ได้');
    }
  } catch (e) {
    console.error('submit comment error', e);
    alert('เกิดข้อผิดพลาดขณะส่งคอมเมนต์');
  } finally {
    commentContent.disabled = false;
    document.getElementById('commentSubmit').disabled = false;
  }
});
</script>
</body>
</html>