<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ดูโพสต์</title>
    <link rel="stylesheet" href="/css/style.css">
    <style>
      /* Make single-post layout match feed/index.html 100% for post structure and gallery behavior.
         All post-related classes (.post, .post-header, .post-body, .post-gallery, .post-img, etc.)
         mirror the feed page so visuals/interaction are identical. */

      .post { position: relative; padding: 12px; border-radius: 10px; background: linear-gradient(180deg,#fff,#fcfdff); margin-bottom: 12px; border: 1px solid rgba(15,23,42,0.03); }
      .post-header { display:flex; align-items:flex-start; gap:12px; width:100%; margin-bottom:6px; }
      .post-avatar .avatar-img { width:48px; height:48px; border-radius:10px; object-fit: cover; flex-shrink:0; }
      .post-header-meta { display:flex; flex-direction:column; gap:2px; min-width:0; }
      .post-username a { font-weight:700; color:var(--text); text-decoration:none; display:inline-block; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:240px; }
      .post-time { color:var(--muted); font-size:0.88rem; }

      .post-body { margin-top: 4px; line-height:1.55; display:flex; flex-direction:column; gap:8px; }
      .post-content { color:#38414b; white-space:pre-wrap; word-break:break-word; }
      .post-img { margin-top:10px; max-width:100%; height:auto; border-radius:8px; display:block; }

      /* Horizontal scrolling gallery — identical rules to index.html */
      .post-gallery {
        display: flex;
        gap: 8px;
        margin-top: 10px;
        overflow-x: auto;
        overflow-y: hidden;
        align-items: flex-start;         /* anchor all images to the top */
        -webkit-overflow-scrolling: touch;
        padding-bottom: 6px;             /* breathing room for horizontal scroll */
        scroll-behavior: smooth;
      }
      .post-gallery .post-img {
        flex: 0 0 auto;                  /* do not shrink/grow, keep intrinsic sizing within limits */
        align-self: flex-start;          /* ensure each image is aligned to top of the gallery row */
        max-height: 420px;               /* max height for images in the gallery */
        max-width: calc(100vw - 96px);   /* ensure very wide images scale down to fit viewport when viewed */
        height: auto;
        width: auto;
        object-fit: contain;             /* avoid cropping; preserve full image within the max box */
        border-radius: 8px;
        display: block;
      }
      .post-gallery.only-one .post-img {
        max-height: 75vh;
        max-width: 100%;
      }

      /* Kebab & popup: same layout as index */
      .post-kebab { background: transparent; border: none; cursor:pointer; width:36px; height:36px; display:inline-flex; align-items:center; justify-content:center; border-radius:8px; margin-left: aut[...]
      .post-kebab:focus { outline: 2px solid rgba(47,128,237,0.12); }

      .post-popup { position:absolute; right:8px; top:44px; left: auto; background:var(--surface); border:1px solid rgba(15,23,42,0.06); border-radius:10px; box-shadow:0 10px 30px rgba(16,24,40,0.08);[...]
      .post-popup a, .post-popup button { display:block; width:100%; padding:10px 12px; text-align:left; border:none; background:transparent; cursor:pointer; font-weight:600; color:var(--text); }
      .post-popup a:hover, .post-popup button:hover { background:#fbfdff; }

      .post-actions { display:none; }

      @media (max-width:800px) {
        .post-header .post-avatar .avatar-img { width:44px; height:44px; }
        .post-header-meta .post-username a { font-size:0.95rem; }
        .post-time { font-size:0.80rem; }
        .post-gallery .post-img { max-height: 260px; max-width: calc(100vw - 56px); }
      }

      /* ===================== Comments (post-like structure) ===================== */
      .comment-list {
        display:flex;
        flex-direction:column;
        gap:12px;
      }
      .comment-item {
        background: linear-gradient(180deg,#fff,#fcfdff);
        border-radius: 10px;
        border: 1px solid rgba(15,23,42,0.03);
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .comment-header {
        display:flex;
        align-items:flex-start;
        gap:12px;
      }
      .comment-avatar .avatar-img {
        width:40px;
        height:40px;
        border-radius: 8px;
        object-fit: cover;
        flex-shrink:0;
      }
      .comment-header-meta {
        display:flex;
        flex-direction:column;
        gap:2px;
        min-width:0;
      }
      .comment-username a {
        font-weight:700;
        color:var(--text);
        text-decoration:none;
        white-space:nowrap;
        overflow:hidden;
        text-overflow:ellipsis;
        display:inline-block;
        max-width: 40ch;
      }
      .comment-time {
        color:var(--muted);
        font-size:0.85rem;
      }
      .comment-body {
        color:#38414b;
        white-space:pre-wrap;
        word-break:break-word;
        margin-left: 52px; /* align body under meta (gives small indent) */
      }
      /* When space is tight, remove left-margin since layout stacks */
      @media (max-width:560px) {
        .comment-body { margin-left: 0; }
      }

      /* ===================== Fixed comment input (bottom) ===================== */
      #commentForm {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 1400;
        background: linear-gradient(180deg,#fff,#fbfdff);
        border-top: 1px solid rgba(15,23,42,0.06);
        padding: 10px;
        display: flex;
        gap: 8px;
        align-items: center;
        box-shadow: 0 -8px 24px rgba(15,23,42,0.06);
      }
      #commentForm textarea {
        flex: 1;
        min-height: 44px;
        max-height: 140px;
        resize: vertical;
        padding: 8px;
        border-radius: 8px;
        border: 1px solid rgba(15,23,42,0.06);
        font-size: 1rem;
      }
      #commentForm button[type="submit"] {
        white-space: nowrap;
        padding: 8px 12px;
      }
      /* spacer to avoid content behind fixed input */
      #commentSpacer { height: 86px; width: 100%; display:block; }
    </style>
</head>
<body>
  <div id="headerSlot"></div>
  <main>
    <div class="container">
      <div class="card" id="postCard">
        <div id="postBox"></div>
        <hr style="margin:16px 0;">
        <div id="commentBox"></div>

        <!-- spacer that ensures bottom fixed comment input doesn't cover content -->
        <div id="commentSpacer" aria-hidden="true"></div>

        <form id="commentForm" class="mt-16 hidden" aria-label="ฟอร์มคอมเมนต์">
          <textarea name="content" placeholder="แสดงความคิดเห็น" required aria-label="ข้อความคอมเมนต์"></textarea>
          <button type="submit" class="btn btn-primary">ส่ง</button>
        </form>
      </div>
    </div>
  </main>
  <div id="footerSlot"></div>

<script src="/js/main.js"></script>
<script>
/*
  This script renders the single post using the exact same DOM structure
  and image/gallery behavior as the feed (index.html). Avatars, kebab popup
  and comments are wired the same way so layout/interaction are 100% identical.
*/
const postId = location.pathname.split('/').pop();
let myUsername;

function escapeHtml(s){ if (s===null||s===undefined) return ''; return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

async function loadPost() {
    const res = await fetch('/api/post/' + encodeURIComponent(postId));
    const data = await res.json();
    if (!data.success) return document.getElementById('postBox').innerText = 'ไม่พบโพสต์';
    const { post, comments, owner, myUsername: apiUsername } = data;
    myUsername = apiUsername;

    // Build DOM using same structure as feed (content first, then images)
    const container = document.getElementById('postBox');
    container.innerHTML = '';
    const art = document.createElement('article');
    art.className = 'post';

    // header
    const header = document.createElement('div'); header.className = 'post-header';
    const avatarA = document.createElement('a'); avatarA.className = 'post-avatar'; avatarA.href = '/user/' + encodeURIComponent(post.username || '');
    const avatarImg = document.createElement('img'); avatarImg.className = 'avatar-img'; avatarImg.alt = post.username || '';
    avatarImg.id = `avatar-${post.username}-${post.id}`;
    avatarImg.dataset.username = post.username || '';
    avatarImg.src = '/img/default_profile.png';
    avatarA.appendChild(avatarImg);
    header.appendChild(avatarA);

    const meta = document.createElement('div'); meta.className = 'post-header-meta';
    const nameDiv = document.createElement('div'); nameDiv.className = 'post-username';
    const nameLink = document.createElement('a'); nameLink.href = '/user/' + encodeURIComponent(post.username || ''); nameLink.textContent = post.username || '(ไม่ระบุ)';
    nameDiv.appendChild(nameLink);
    const timeDiv = document.createElement('div'); timeDiv.className = 'post-time small'; timeDiv.textContent = new Date(post.createdAt).toLocaleString();
    meta.appendChild(nameDiv); meta.appendChild(timeDiv);
    header.appendChild(meta);

    // kebab (same as feed)
    const kebab = document.createElement('button');
    kebab.className = 'post-kebab';
    kebab.type = 'button';
    kebab.setAttribute('aria-haspopup','true');
    kebab.setAttribute('aria-expanded','false');
    kebab.title = 'ตัวเลือกโพสต์';
    kebab.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#97a0b3" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" c[...]
    header.appendChild(kebab);

    art.appendChild(header);

    // body
    const body = document.createElement('div'); body.className = 'post-body';

    // --- CONTENT FIRST (exactly like index) ---
    const contentDiv = document.createElement('div');
    contentDiv.className = 'post-content';
    contentDiv.innerHTML = escapeHtml(post.content || '');
    body.appendChild(contentDiv);

    // --- IMAGES AFTER CONTENT ---
    const imgs = Array.isArray(post.images) ? post.images.slice() : (post.image ? [post.image] : []);
    if (imgs.length === 1) {
      const im = document.createElement('img');
      im.className = 'post-img';
      im.src = imgs[0];
      im.alt = 'post image';
      im.loading = 'lazy';
      body.appendChild(im);
    } else if (imgs.length > 1) {
      const gallery = document.createElement('div');
      gallery.className = 'post-gallery';
      if (imgs.length === 1) gallery.classList.add('only-one');
      for (const src of imgs) {
        const im = document.createElement('img');
        im.className = 'post-img';
        im.src = src;
        im.alt = 'post image';
        im.loading = 'lazy';
        gallery.appendChild(im);
      }
      body.appendChild(gallery);
    }

    const actionsDiv = document.createElement('div'); actionsDiv.className = 'post-actions';
    if (myUsername === post.username) {
      const editA = document.createElement('a'); editA.className = 'btn btn-ghost'; editA.href = '/post/' + post.id + '/edit'; editA.textContent = 'แก้ไข';
      actionsDiv.appendChild(editA);
      const delBtn = document.createElement('button'); delBtn.className = 'btn btn-ghost'; delBtn.id = 'delBtn'; delBtn.type='button'; delBtn.textContent = 'ลบ';
      actionsDiv.appendChild(delBtn);
    }
    body.appendChild(actionsDiv);

    art.appendChild(body);
    container.appendChild(art);

    // load avatar similarly to feed implementation (apply profilePic to all matching imgs)
    (async () => {
      try {
        const up = await fetch(`/api/user/${encodeURIComponent(post.username)}`);
        const ud = await up.json();
        if (ud && ud.success && ud.profile && ud.profile.profilePic) {
          const imgElem = document.getElementById("avatar-"+post.username+"-"+post.id);
          if (imgElem) imgElem.src = ud.profile.profilePic;
        }
      } catch(e){}
    })();

    // kebab popup logic (same behavior as feed)
    kebab.addEventListener('click', function(ev) {
      ev.preventDefault();
      ev.stopPropagation();
      // remove existing popup
      const existing = art.querySelector('.post-popup');
      if (existing) { existing.remove(); kebab.setAttribute('aria-expanded','false'); return; }

      const popup = document.createElement('div');
      popup.className = 'post-popup';
      popup.dataset.postId = post.id;

      const isOwner = (myUsername && post.username && myUsername === post.username);

      if (isOwner) {
        const editA = document.createElement('a');
        editA.href = '/post/' + encodeURIComponent(post.id) + '/edit';
        editA.textContent = 'แก้ไขโพสต์';
        popup.appendChild(editA);

        const delBtn = document.createElement('button');
        delBtn.type = 'button';
        delBtn.textContent = 'ลบโพสต์';
        delBtn.addEventListener('click', async function (e) {
          e.preventDefault();
          if (!confirm('ลบโพสต์นี้?')) return;
          try {
            await fetch('/api/post/' + encodeURIComponent(post.id), { method: 'DELETE' });
            location.replace('/');
          } catch (err) {
            alert('เกิดข้อผิดพลาดขณะลบโพสต์');
          }
        });
        popup.appendChild(delBtn);
      } else {
        const profileA = document.createElement('a');
        profileA.href = '/user/' + encodeURIComponent(post.username || '');
        profileA.textContent = 'ไปยังโปรไฟล์';
        popup.appendChild(profileA);

        const reportBtn = document.createElement('button');
        reportBtn.type = 'button';
        reportBtn.textContent = 'รายงานโพสต์';
        reportBtn.addEventListener('click', function () {
          alert('ฟีเจอร์รายงานยังไม่เปิดใช้งาน');
        });
        popup.appendChild(reportBtn);
      }

      art.appendChild(popup);
      kebab.setAttribute('aria-expanded','true');
      // close popup when clicking outside
      setTimeout(() => {
        const onDoc = (ev) => {
          if (!popup.contains(ev.target) && ev.target !== kebab) {
            popup.remove();
            kebab.setAttribute('aria-expanded','false');
            document.removeEventListener('click', onDoc, true);
          }
        };
        document.addEventListener('click', onDoc, true);
      }, 0);
    });

    // render comments using post-like structure (avatar + meta + body)
    renderComments(comments || []);

    // render comments end
    // load avatars for comments
    loadCommentAvatars(comments || []);
}

function renderComments(comments) {
  const box = document.getElementById('commentBox');
  box.innerHTML = '';
  const h3 = document.createElement('h3');
  h3.textContent = 'คอมเมนต์';
  box.appendChild(h3);

  const list = document.createElement('div');
  list.className = 'comment-list';

  if (!comments || comments.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'small';
    empty.textContent = 'ยังไม่มีคอมเมนต์';
    list.appendChild(empty);
  } else {
    for (const c of comments) {
      const item = document.createElement('article');
      item.className = 'comment-item';
      item.dataset.commentId = c.id;

      // header row (avatar + meta + optional kebab)
      const header = document.createElement('div');
      header.className = 'comment-header';

      const avatarLink = document.createElement('a');
      avatarLink.className = 'comment-avatar';
      avatarLink.href = '/user/' + encodeURIComponent(c.username || '');
      const avatarImg = document.createElement('img');
      avatarImg.className = 'avatar-img';
      avatarImg.alt = c.username || '';
      avatarImg.dataset.username = c.username || '';
      avatarImg.src = '/img/default_profile.png';
      avatarLink.appendChild(avatarImg);
      header.appendChild(avatarLink);

      const meta = document.createElement('div');
      meta.className = 'comment-header-meta';
      const nameDiv = document.createElement('div');
      nameDiv.className = 'comment-username';
      const nameLink = document.createElement('a');
      nameLink.href = '/user/' + encodeURIComponent(c.username || '');
      nameLink.textContent = c.username || '(ไม่ระบุ)';
      nameDiv.appendChild(nameLink);
      const timeDiv = document.createElement('div');
      timeDiv.className = 'comment-time small';
      timeDiv.textContent = new Date(c.createdAt).toLocaleString();
      meta.appendChild(nameDiv);
      meta.appendChild(timeDiv);
      header.appendChild(meta);

      // optional kebab for own comment
      if (myUsername && myUsername === c.username) {
        const kebab = document.createElement('button');
        kebab.className = 'post-kebab';
        kebab.type = 'button';
        kebab.title = 'ตัวเลือก';
        kebab.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#97a0b3" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg>`;
        kebab.addEventListener('click', (ev) => {
          ev.stopPropagation();
          if (!confirm('ลบคอมเมนต์นี้?')) return;
          deleteComment(c.id);
        });
        // push kebab to the far right
        kebab.style.marginLeft = 'auto';
        header.appendChild(kebab);
      }

      item.appendChild(header);

      const body = document.createElement('div');
      body.className = 'comment-body';
      body.innerHTML = escapeHtml(c.content || '');
      item.appendChild(body);

      // keyboard support
      item.tabIndex = 0;
      item.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          // focus textarea so user can quickly reply
          const ta = document.querySelector('#commentForm textarea');
          if (ta) ta.focus();
        }
      });

      list.appendChild(item);
    }
  }

  box.appendChild(list);

  // show comment form for logged-in users
  if (myUsername) {
    const form = document.getElementById('commentForm');
    if (form) form.classList.remove('hidden');
  }
}

// batch-load avatars for comment authors (deduplicated)
async function loadCommentAvatars(comments) {
  const imgs = Array.from(document.querySelectorAll('img[data-username]'));
  const uniq = new Set();
  for (const img of imgs) {
    const u = (img.dataset.username || '').trim();
    if (u) uniq.add(u);
  }
  // for each username, fetch once
  for (const username of uniq) {
    (async () => {
      try {
        const res = await fetch('/api/user/' + encodeURIComponent(username));
        if (!res.ok) return;
        const j = await res.json();
        if (!j || !j.success || !j.profile) return;
        const pic = j.profile.profilePic;
        if (!pic) return;
        document.querySelectorAll('img[data-username="' + CSS.escape(username) + '"]').forEach(i => {
          i.addEventListener('error', function onErr() {
            i.removeEventListener('error', onErr);
            i.src = '/img/default_profile.png';
          }, { once: true });
          i.src = pic;
        });
      } catch (e) {
        console.warn('loadCommentAvatars error', e && e.message);
      }
    })();
  }
}

loadPost();

document.getElementById('commentForm').onsubmit = async e => {
    e.preventDefault();
    const fd = new FormData(e.target);
    const body = Object.fromEntries(fd.entries());
    try {
      const res = await fetch('/api/post/' + encodeURIComponent(postId) + '/comment', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });
      const data = await res.json();
      if (data && data.success) {
        e.target.reset();
        // reload comments only (avoid full page navigation)
        const res2 = await fetch('/api/post/' + encodeURIComponent(postId));
        const d2 = await res2.json();
        if (d2 && d2.success) renderComments(d2.comments || []);
      } else {
        alert('ไม่สามารถส่งคอมเมนต์ได้');
      }
    } catch (err) {
      alert('ไม่สามารถส่งคอมเมนต์ได้');
    }
};

window.deleteComment = async (cid) => {
    if (confirm('ยืนยันลบคอมเมนต์?')) {
        await fetch(`/api/post/${encodeURIComponent(postId)}/comment/${encodeURIComponent(cid)}`, {method:'DELETE'});
        // reload comments
        const res2 = await fetch('/api/post/' + encodeURIComponent(postId));
        const d2 = await res2.json();
        if (d2 && d2.success) renderComments(d2.comments || []);
    }
};
</script>
</body>
</html>